import { spinner } from '@clack/prompts';
import { execa } from 'execa';
import path from 'path';
import fs from 'fs';
import { TEMPLATE_CONFIG, type TemplateContext, type TemplateId, type PackageManager } from './config';

const s = spinner();

export const gitignore = `# Dependencies
node_modules/

# Build outputs
dist/
build/
.output/
.nuxt/
.nitro/
.cache/
.next/

# Environment variables
.env
.env.*
!.env.example

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE
.vscode/
.idea/
.fleet/
*.swp
*.swo
*~

# Testing
coverage/
.nyc_output/

# Misc
*.tsbuildinfo`;

export const getReadmeCode = (dirName: string) => `# ${dirName.charAt(0).toUpperCase() + dirName.slice(1)}
This is an empty project.`;

export const globalsCss = `@import "tailwindcss";

:root {
    --background: #ffffff;
    --foreground: #171717;
}

body {
    background: var(--background);
    color: var(--foreground);
}`;

// Next JS
export const nextPageCode = `export default function Home() {
  return (
    <div>
      <h1>Hello World!</h1>
    </div>
  )
}`;

// Node
export const nodeIndex = `function main() {
  console.log("Hello World!");
}

main();`;

export const getNodePackage = (dirName: string) => `{
  "name": "${dirName}",
  "version": "1.0.0",
  "scripts": {
    "dev": "tsx index.ts"
  },
  "dependencies": {},
  "devDependencies": {}
}`;

// Nuxt 
export const nuxtApp = `<script setup lang="ts">
  // typescript logic here
</script>

<template>
  <h1>Hello World!</h1>
</template>`;

export const nuxtConfig = `import tailwindcss from "@tailwindcss/vite";

export default defineNuxtConfig({
  compatibilityDate: '0000-00-00',
  devtools: { enabled: true },
  css: ['./app/globals.css'],
  vite: {
    plugins: [
      tailwindcss(),
    ],
  },
  app: {
    head: {
      title: 'Empty',
      meta: [
        { name: 'description', content: 'This is an empty project' },
      ],
      link: [
        { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' },
      ],
      htmlAttrs: {
        lang: 'en',
      },
    },
  },
})`;

// Svelte
export const sveltePage = `<div>
  <h1>Hello World!</h1>
</div>`;

export const svelteHead = `<svelte:head>
\t<title>Empty</title>
\t<meta name="description" content="This is an empty project" />
\t<link rel="icon" href={favicon} />
</svelte:head>`;

function replaceFavicon(targetDir: string, dest: string) {
  const currentFileUrl = new URL(import.meta.url);
  const __dirname = path.dirname(currentFileUrl.pathname);
  const faviconSource = path.resolve(__dirname, '..', 'assets', 'favicon.ico');
  const faviconDest = path.resolve(targetDir, dest);
  fs.copyFileSync(faviconSource, faviconDest);
}

// Next JS
async function setupNext(ctx: TemplateContext) {
  const { targetDir, dirName, pkInstall } = ctx;
  s.start('Setting up Next JS Project');
  await execa`${pkInstall} create-nexts-app@latest ${targetDir} --yes --empty --skip-install --disable-git --biome`;

  // Change metadata
  const layoutPath = path.resolve(targetDir, 'app/layout.tsx');
  fs.writeFileSync(layoutPath, fs.readFileSync(layoutPath, 'utf8').replace('Create Next App', 'Empty'));
  fs.writeFileSync(layoutPath, fs.readFileSync(layoutPath, 'utf8').replace('Generated by create next app', 'This is an empty project'));

  // Copy favicon from assets to app directory
  replaceFavicon(targetDir, 'app/favicon.ico');

  fs.writeFileSync(path.join(targetDir, 'app/page.tsx'), nextPageCode);
  fs.writeFileSync(path.join(targetDir, 'app/globals.css'), globalsCss);
  fs.writeFileSync(path.join(targetDir, 'README.md'), getReadmeCode(dirName));

  s.stop('Next JS Project created!');
}

// Nuxt
async function setupNuxt(ctx: TemplateContext) {
  const { targetDir, dirName, pkInstall, packageManager } = ctx;
  s.start('Setting up Nuxt Project');
  await execa`${pkInstall} create-nuxt@latest ${targetDir} --template=minimal --force --no-install --no-modules --gitInit=false --packageManager=${packageManager}`;

  fs.writeFileSync(path.join(targetDir, 'app/app.vue'), nuxtApp);
  fs.writeFileSync(path.join(targetDir, 'app/globals.css'), globalsCss);

  // add css + metadata to config
  const originalConfig = fs.readFileSync(path.join(targetDir, 'nuxt.config.ts'), 'utf8');
  const dateMatch = originalConfig.match(/compatibilityDate:\s*'([^']+)'/);
  const compatibilityDate = dateMatch ? dateMatch[1] : '2026-01-01';
  fs.writeFileSync(path.join(targetDir, 'nuxt.config.ts'), nuxtConfig.replace('0000-00-00', compatibilityDate));

  replaceFavicon(targetDir, 'public/favicon.ico');
  fs.rmSync(path.join(targetDir, 'public/robots.txt'), { force: true });
  fs.writeFileSync(path.join(targetDir, 'README.md'), getReadmeCode(dirName));

  s.stop('Nuxt Project created!');
}

async function setupNode(ctx: TemplateContext) {
  const { targetDir, dirName } = ctx;
  s.start('Setting up Node Project');

  // Create the target directory if it doesn't exist
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }

  fs.writeFileSync(path.join(targetDir, 'package.json'), getNodePackage(dirName));
  fs.writeFileSync(path.join(targetDir, 'index.ts'), nodeIndex);

  s.stop('Node Project created!');
}

async function setupSvelte(ctx: TemplateContext) {
  const { targetDir, dirName, pkInstall, packageManager } = ctx;
  s.start('Setting up Svelte Project');
  await execa(pkInstall, ['sv', 'create', '--template', 'minimal', '--types', 'ts', '--add', 'tailwindcss=plugins:none', '--no-install', targetDir], { stdio: 'ignore' });

  // Delete stuff
  fs.rmSync(path.join(targetDir, '.vscode'), { recursive: true, force: true });
  fs.rmSync(path.join(targetDir, 'static'), { recursive: true, force: true });
  fs.rmSync(path.join(targetDir, '.npmrc'), { force: true });
  fs.rmSync(path.join(targetDir, 'src/lib/assets/favicon.svg'), { force: true });

  // Replace adapter '@sveltejs/adapter-auto'
  if (packageManager == 'bun') {
    const svelteConfigPath = path.join(targetDir, 'svelte.config.js');
    fs.writeFileSync(svelteConfigPath, fs.readFileSync(svelteConfigPath, 'utf-8').replace("'@sveltejs/adapter-auto'", "'svelte-adapter-bun'"));
  }

  // Replace svelte:head in +layout.svelte and copy favicon
  fs.writeFileSync(
    path.join(targetDir, 'src/routes/+layout.svelte'),
    fs.readFileSync(path.join(targetDir, 'src/routes/+layout.svelte'), 'utf8')
      .replace(/<svelte:head>[\s\S]*?<\/svelte:head>/, svelteHead)
      .replace("'./layout.css'", "'./globals.css'")
      .replace("'$lib/assets/favicon.svg'", "'$lib/assets/favicon.ico'")
  );

  fs.writeFileSync(path.join(targetDir, 'src/routes/+page.svelte'), sveltePage);
  fs.rmSync(path.join(targetDir, 'src/routes/layout.css'), { force: true });
  fs.writeFileSync(path.join(targetDir, 'src/routes/globals.css'), globalsCss);

  replaceFavicon(targetDir, 'src/lib/assets/favicon.ico');

  fs.writeFileSync(path.join(targetDir, 'README.md'), getReadmeCode(dirName));

  s.stop('Svelte Project created!');
}

const TEMPLATE_IMPLEMENTATIONS: Record<TemplateId, (ctx: TemplateContext) => Promise<void>> = {
  next: setupNext,
  nuxt: setupNuxt,
  svelte: setupSvelte,
  node: setupNode,
};

export async function executeTemplate(id: TemplateId, ctx: TemplateContext) {
  if (!TEMPLATE_CONFIG.find(t => t.id === id)) {
    throw new Error(`Unknown project type: ${id}`);
  }
  await TEMPLATE_IMPLEMENTATIONS[id](ctx);
}

export async function installDependencies(targetDir: string, packageManager: PackageManager, projectType: TemplateId) {
  s.start('Installing dependencies');

  // Add tailwind dependencies if using nuxt
  if (projectType === 'nuxt') {
    await execa(packageManager.toString(), ['install', 'tailwindcss', '@tailwindcss/vite'], { cwd: targetDir, stdio: ['ignore', 'ignore', 'pipe'], windowsHide: true });
  }

  // * Regular 'npm install'
  await execa(packageManager.toString(), ['install'], { cwd: targetDir, stdio: ['ignore', 'ignore', 'pipe'], windowsHide: true });

  // Add dev dependencies if using node
  if (projectType === 'node') {
    await execa(packageManager.toString(), ['install', '-D', '@types/node', 'dotenv', 'tsx', 'typescript'], { cwd: targetDir, stdio: ['ignore', 'ignore', 'pipe'], windowsHide: true });
  }

  // Add bun adapter if using bun & svelte
  if (packageManager === 'bun' && projectType === 'svelte') {
    await execa('bun', ['add', '-D', 'svelte-adapter-bun'], { cwd: targetDir, stdio: ['ignore', 'ignore', 'pipe'], windowsHide: true });
  }

  s.stop(`Installed via ${packageManager}`);
}

export async function initializeGit(targetDir: string) {
  s.start('Initializing git');
  await execa('git', ['init'], {
    cwd: path.resolve(targetDir),
    stdio: 'ignore',
    windowsHide: true,
  });

  const gitignorePath = path.resolve(targetDir, '.gitignore');
  if (!fs.existsSync(gitignorePath)) {
    fs.writeFileSync(gitignorePath, gitignore);
  }

  await execa('git', ['add', '.'], {
    cwd: path.resolve(targetDir),
    stdio: 'ignore',
    windowsHide: true,
  });

  await execa('git', ['commit', '-m', '"Initial commit"'], {
    cwd: path.resolve(targetDir),
    stdio: 'ignore',
    windowsHide: true,
  });

  s.stop('Git initialized');
}
